// Package runtime encompases the runtime data created by the defimpl
// utility.

package runtime

import "fmt"
import "reflect"


// interfaceToImpl maps from the interfaces that defimpl has defined
// implementation structs for to the corresponding struct pointer types.
var interfaceToImpl = map[reflect.Type]reflect.Type{}

//iImplToInterface maps from an implementation type defined by the
// defimpl utility to the interface type it is defined for.
var implToInterface = map[reflect.Type]reflect.Type{}

// InterfaceToImpl returns the implementation type (as defined by
// defimpl) for the specified interface type.
func InterfaceToImpl(inter reflect.Type) reflect.Type {
	return interfaceToImpl[inter]
}

// ImplToInterface returns the interface type that the type impl was
// defined for.
func ImplToInterface(impl reflect.Type) reflect.Type {
	return implToInterface[impl]
}

// InterfaceFor returns the iinterface type for the specified type,
// assuming that they are under the perview of defimpl.
func InterfaceFor(t reflect.Type) reflect.Type {
	switch t.Kind() {
	case reflect.Interface:
		return t
	case reflect.Ptr:
		if t.Elem().Kind() == reflect.Struct {
			return ImplToInterface(t)
		}
		return nil
	case reflect.Struct:
		return ImplToInterface(reflect.PtrTo(t))
	}
	return nil
}

// ImplFor returns the iinterface type for the specified type,
// assuming that they are under the perview of defimpl.
func ImplFor(t reflect.Type) reflect.Type {
	switch t.Kind() {
	case reflect.Ptr:
		if t.Elem().Kind() == reflect.Struct {
			return t
		}
		return nil
	case reflect.Struct:
		return reflect.PtrTo(t)
	case reflect.Interface:
		return InterfaceToImpl(t)
	}
	return nil
}


// Register associates the specified interface and implementation
// types so that they can be found at run time.
//
// Regiuster should only be called from init functions defined in the
// code generated by the defimpl utilitty.
func Register(inter reflect.Type, impl reflect.Type) {
	if inter == nil {
		panic(fmt.Sprintf("defimpl/runtime.Register(%v, %v): interface is nil", inter, impl))
	}
	if impl == nil {
		panic(fmt.Sprintf("defimpl/runtime.Register(%v, %v): impl is nil", inter, impl))
	}
	interfaceToImpl[inter] = impl
	implToInterface[impl] = inter
}

func Dump() {
	fmt.Println("interfaceToImpl:")
	for k, v := range interfaceToImpl {
		fmt.Println("\t", k, "\t", v)
	}
	fmt.Println("implToInterface:")
	for k, v := range implToInterface {
		fmt.Println("\t", k, "\t", v)
	}
}

