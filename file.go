package main

import "bytes"
import "fmt"
import "go/ast"
import "go/format"
import "go/parser"
import "go/types"
import "os"
import "path"
import "path/filepath"
import "strconv"
import "strings"
import "text/template"
import "defimpl/util"


// File represents a single file to be processed.
type File struct {
	AstFile       *ast.File
	InputFilePath string
	Package       string
	Interfaces    []*InterfaceDefinition
	Output        *ast.File
}

func (f *File) Defimpl() string {
	return os.Args[0]
}

type ToImport struct {
	Name string
	Path string
}

func (f *File) Qualifier(pkg *types.Package) string {
	ppath := pkg.Path()
	for _, ispec := range f.AstFile.Imports {
		unq, err := strconv.Unquote(ispec.Path.Value)
		if err != nil {
			panic(err)
		}
		if unq == ppath {
			if ispec.Name == nil {
				_, base := path.Split(ppath)
				return base
			} else {
				return ispec.Name.Name
			}
		}
	}
	return ""
}

var _ types.Qualifier = (&File{}).Qualifier

func (f *File) OutputFilePath() string {
	input := f.InputFilePath
	return filepath.Join(filepath.Dir(input), "impl_"+filepath.Base(input))
}

func IsOutputFilePath(f string) bool {
	return strings.HasPrefix(filepath.Base(f), "impl_")
}

// NewFile returns a File object for the given ast.File.
// Interfaces will be filled in.
func NewFile(ctx *context, astFile *ast.File) *File {
	f := &File{
		AstFile:       astFile,
		InputFilePath: ctx.fset.Position(astFile.Package).Filename,
		Package:       astFile.Name.Name,
		Interfaces:    []*InterfaceDefinition{},
	}
	for _, decl := range astFile.Decls {
		if id := NewInterface(ctx, f , decl); id != nil {
			f.Interfaces = append(f.Interfaces, id)
		}
	}
	return f
}

func (f *File) Write(ctx *context) error {
	if !f.AnyStructs() {
		return nil
	}
	output := f.OutputFilePath()
	out, err := os.Create(output)
	if err != nil {
		return fmt.Errorf("Can't create %s: %s", output, err)
	}
	f.GenerateCode(ctx, output)
	format.Node(out, ctx.fset, f.Output)
	out.Close()
	fmt.Printf("Wrote %s\n", output)
	return nil
}

// AnyStructs returns true if the File defines interfaces for which
// impl structs will be defined.
func (f *File) AnyStructs() bool {
	for _, i := range f.Interfaces {
		if i.DefinesStruct() {
			return true
		}
	}
	return false
}

func (f *File) GenerateCode(ctx *context, filepath string) {
	writer := bytes.NewBufferString("")
	err := OutputFileTemplate.Execute(writer, f)
	if err != nil {
		fmt.Fprintf(os.Stderr, "defimpl: %s\n", writer.String())
		panic(err)
	}
	parsed, err := parser.ParseFile(ctx.fset, filepath, writer.String(), parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "defimpl: %s\n", writer.String())
		panic(err)
	}
	errs := util.EnsureImports(ctx.fset, f.AstFile, parsed)
	for _, err := range errs {
		fmt.Fprintf(os.Stderr, "defimpl: %s\n", err)
	}
	f.Output = parsed
}

// OutputFileTemplate is the template for generating the output file
// containing the programatically generated struct and method definitions
// that implement the interfaces in the input file.
// The parameter is a File object.
var OutputFileTemplate *template.Template = template.Must(template.New("OutputFileTemplate").Funcs(map[string]interface{}{
	//		"NormalizedType": util.NormalizedType,
	"GlobalDefinitions": GlobalDefinitions,
}).Parse(`
// This file was automatically generated by {{.Defimpl}} from {{.InputFilePath}}.
package {{.Package}}

import "reflect"
import "defimpl/runtime"

{{with $file := . -}}
	{{- range .Interfaces -}}
		{{- if .DefinesStruct -}}
			type {{.StructName}} struct {
				{{- range .VerbPhrases}}
					{{.Verb.StructBody .}}
				{{- end -}}
			}

			var _ {{.InterfaceName}} = (*{{.StructName}})(nil)

			var _ = func() error {
				t := reflect.TypeOf(func({{.InterfaceName}}, *{{.StructName}}){})
				runtime.Register(t.In(0), t.In(1))
				return nil
			}()
			{{range .VerbPhrases -}}
				{{GlobalDefinitions .}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{- end}}
`)) // end template
