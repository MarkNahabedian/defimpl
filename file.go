package main

import "bytes"
import "fmt"
import "go/ast"
import "go/format"
import "go/parser"
import "os"
import "path/filepath"
import "strings"
import "text/template"

// File represents a single file to be processed.
type File struct {
	AstFile *ast.File
	InputFilePath string
	Package string
	Interfaces []*InterfaceDefinition
}

func (f *File) Defimpl() string {
	return os.Args[0]
}

func (f *File) OutputFilePath() string {
	input := f.InputFilePath
	return filepath.Join(filepath.Dir(input), "impl_" + filepath.Base(input))
}

func IsOutputFilePath(f string) bool {
	return strings.HasPrefix(filepath.Base(f), "impl_")
}

// AddImports addresses the need to include imports for captured
// refernces like type definitions.
// It will need to be used for each types.Type that is included in the output file.
func (f *File) AddImports(ctx *context, astFile *ast.File) {
	for _, i := range f.Interfaces {
		i.AddImports(ctx, f.AstFile, astFile)
	}
}

// NewFile returns a File object for the given ast.File.
// Interfaces will be filled in.
func NewFile(ctx *context, astFile *ast.File) *File {
	f := &File{
		AstFile: astFile,
		InputFilePath: ctx.fset.Position(astFile.Package).Filename,
		Package: astFile.Name.Name,
		Interfaces: []*InterfaceDefinition{},
	}
	for _, decl := range astFile.Decls {
		if id := NewInterface(ctx, decl); id != nil {
			fmt.Printf("interface definition %v\n", id)
			f.Interfaces = append(f.Interfaces, id)
		}
	}
	return f
}

func (f *File) Write(ctx *context) error {
	if len(f.Interfaces) == 0 {
		return nil
	}
	output := f.OutputFilePath()
	out, err := os.Create(output)
	if err != nil {
		return fmt.Errorf("Can't create %s: %s", output, err)
	}
	format.Node(out, ctx.fset, f.GenerateCode(ctx))
	out.Close()
	fmt.Printf("Wrote %s\n", output)
	return nil
}

func (f *File) GenerateCode(ctx *context) *ast.File {
	writer := bytes.NewBufferString("")
	err := OutputFileTemplate.Execute(writer, f)
	if err != nil {
		panic(err)
	}
	parsed, err := parser.ParseFile(ctx.fset, "", writer.String(), parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", writer.String())
		panic(err)
	}
	f.AddImports(ctx, parsed)
	return parsed
}

// OutputFileTemplate is the template for generating the output file
// containing the programatically generated struct and method definitions
// that implement the interfaces in the input file.
// The parameter is a File object.
var OutputFileTemplate *template.Template = template.Must(template.New("OutputFileTemplate").Funcs(map[string]interface{} {
//		"NormalizedType": util.NormalizedType,
	}).Parse(`
// This file was automatically generated by {{.Defimpl}} from {{.InputFilePath}}.
package {{.Package}}
	{{with $file := .}}
		{{range .Interfaces}}
			type {{.StructName}} struct {
				{{range .SlotSpecs}}
					{{.Name}} {{.Type}}
				{{end}}
			}
			{{with $interface := .}}
				{{range .SlotSpecs}}
					{{range .Verbs}}
						{{.RunTemplate}}
					{{end}}
				{{end}}
			{{end}}
		{{end}}
	{{end}}
`)) // end template

