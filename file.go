package main

import "bytes"
import "fmt"
import "go/ast"
import "go/format"
import "go/parser"
import "go/types"
import "os"
import "path/filepath"
import "strings"
import "text/template"
import "defimpl/util"


// File represents a single file to be processed.
type File struct {
	AstFile       *ast.File
	InputFilePath string
	Package       string
	Interfaces    []*InterfaceDefinition
}

func (f *File) Defimpl() string {
	return os.Args[0]
}

func (f *File) OutputFilePath() string {
	input := f.InputFilePath
	return filepath.Join(filepath.Dir(input), "impl_"+filepath.Base(input))
}

func IsOutputFilePath(f string) bool {
	return strings.HasPrefix(filepath.Base(f), "impl_")
}

// NewFile returns a File object for the given ast.File.
// Interfaces will be filled in.
func NewFile(ctx *context, astFile *ast.File) *File {
	f := &File{
		AstFile:       astFile,
		InputFilePath: ctx.fset.Position(astFile.Package).Filename,
		Package:       astFile.Name.Name,
		Interfaces:    []*InterfaceDefinition{},
	}
	for _, decl := range astFile.Decls {
		if id := NewInterface(ctx, f.Package, decl); id != nil {
			f.Interfaces = append(f.Interfaces, id)
		}
	}
	return f
}

func (f *File) Write(ctx *context) error {
	if !f.AnyStructs() {
		return nil
	}
	output := f.OutputFilePath()
	out, err := os.Create(output)
	if err != nil {
		return fmt.Errorf("Can't create %s: %s", output, err)
	}
	format.Node(out, ctx.fset, f.GenerateCode(ctx, output))
	out.Close()
	fmt.Printf("Wrote %s\n", output)
	return nil
}

func (f *File) AnyStructs() bool {
	for _, i := range f.Interfaces {
		if i.DefinesStruct() {
			return true
		}
	}
	return false
}

func (f *File) GenerateCode(ctx *context, filepath string) *ast.File {
	writer := bytes.NewBufferString("")
	err := OutputFileTemplate.Execute(writer, f)
	if err != nil {
		panic(err)
	}
	parsed, err := parser.ParseFile(ctx.fset, filepath, writer.String(), parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "defimpl: %s\n", writer.String())
		panic(err)
	}
	errs := util.EnsureImports(ctx.fset, f.AstFile, parsed)
	for _, err := range errs {
		fmt.Fprintf(os.Stderr, "defimpl: %s\n", err)
	}
	return parsed
}

// OutputFileTemplate is the template for generating the output file
// containing the programatically generated struct and method definitions
// that implement the interfaces in the input file.
// The parameter is a File object.
var OutputFileTemplate *template.Template = template.Must(template.New("OutputFileTemplate").Funcs(map[string]interface{}{
	//		"NormalizedType": util.NormalizedType,
	"ExprString": types.ExprString,
}).Parse(`
// This file was automatically generated by {{.Defimpl}} from {{.InputFilePath}}.
package {{.Package}}

import "reflect"
import "defimpl/runtime"

	{{- with $file := . -}}
		{{- range .Interfaces -}}
			{{- if .DefinesStruct -}}
				{{- if not .IsAbstract}}
					type {{.StructName}} struct {
						{{- range .SlotSpecs -}}
						        {{- if not (eq .Name "") }}
							        {{.Name}} {{ExprString .Type}}
							{{end -}}
					 	{{end}}
						{{- /* Fields required to support abstract inherited interfaces: */ -}}
						{{with $thisInterface := .}}
							{{- if gt (len .AllInherited) 0}}
								// NEED TO FIGURE OUT HOW TO USE STRUCT EMBEDDING.
							{{end -}}
							{{- range $inherited := .AllInherited -}}
								{{- if not $inherited.DefinesStruct}}
									// Fields to support the {{$inherited.InterfaceName}} interface:
									{{range $inherited.SlotSpecs}}
										{{.Name}} {{ExprString .Type}}
								 	{{end}}
								{{- else -}}
									// Interface {{$inherited.InterfaceName}} has a concrete implementation
									{{$inherited.StructName}}
								{{end -}}
							{{end}}
						{{end}}
					}
					var _ {{.InterfaceName}} = (*{{.StructName}})(nil)
					func init() {
						inter := reflect.TypeOf(func(t {{.InterfaceName}}){}).In(0)
						var impl *{{.StructName}}
						runtime.Register(inter, reflect.TypeOf(impl))
					}
					{{with $interface := .}}
						{{range .SlotSpecs}}
							{{range .Verbs}}
								{{.RunTemplate}}
							{{end}}
						{{end}}
						{{range .InheritedVerbs}}
							{{.RunTemplate}}
						{{end}}
					{{end}}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end}}
`)) // end template
