package main

import "bytes"
import "fmt"
import "defimpl/util"
import "go/ast"
import "go/parser"
import "go/token"
import "go/types"
import "text/template"


type fakeInterfaceDefinition struct {
	Package string
}

// CheckSignatures is used in the NewVerbPhrase method of each verb to
// make sure that a method Field's FuncType in an interface matches
// that expected by the method definition that will be generated by
// the template returned by the VerbDefinition's MethodTemplate
// method.
//
// That template is applied to a special parameter that substitutes
// specific "variable names" into the template.
//
// Because the template substitution expressions might include other
// operations on the value of a template parameter, MatchVar should be
// used in the substitutions.  Identity methods can be defined on
// MatchVar for any operations that the template might want to
// perform.
//
// CheckSignatures then executes the template and parses the result to
// serve as the pattern argument of AstMatch.
func CheckSignatures(ctx *context, vd VerbDefinition, pkg string, field *ast.Field, tmpl *template.Template) (types.Type, error) {
	w := &bytes.Buffer{}
	fmt.Fprintf(w, "package %s\n\n", pkg)
	if err := tmpl.Execute(w, &CheckSignaturesVerbPhraseSurrogate{
		MethodName: MatchVar("IGNORE"),
		InterfaceName: MatchVar("IGNORE"),
		StructName: MatchVar("IGNORE"),
		SlotName: MatchVar("IGNORE"),
		SlotType: MatchVar("_SLOT_TYPE"),
		InterfaceDefinition: fakeInterfaceDefinition {
			Package: "",
		},
	}); err != nil {
		return nil, err
	}
	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, "pattern", w.String(), parser.ParseComments)
	if err != nil {
		return nil, err
	}
	var fd *ast.FuncDecl
	// Find the method definition from the parsed template result:
	for _, decl := range parsed.Decls {
		if fd1, ok := decl.(*ast.FuncDecl); ok {
			fd = fd1
			break
		}
	}
	if fd == nil {
		return nil, fmt.Errorf("verb MethodTemplate for %q should have exactly one FuncDecl",
			vd.Tag())
	}
	scratchpad :=  map[string]interface{}{}
	// Match the method definition with the Field of the
	// interface, extracting the data type:
	matched, err := util.AstMatch(fd.Type, field.Type, scratchpad)
	if err != nil {
		return nil, fmt.Errorf("defimpl: %s: %s",
			ctx.fset.Position(field.Comment.List[0].Slash).String(),
			err)
	}
	if !matched {
		return nil, fmt.Errorf("Method signature inappropriate for verb %q",
			vd.Tag())
	}
	if t, ok := scratchpad["_SLOT_TYPE"]; ok {
		return ctx.info.Types[t.(ast.Expr)].Type, nil
	} else {
		return nil, nil
	}
}


type CheckSignaturesVerbPhraseSurrogate struct {
	MethodName MatchVar
	InterfaceName MatchVar
	StructName MatchVar
	SlotName MatchVar
	SlotType MatchVar
	InterfaceDefinition fakeInterfaceDefinition
}

// MatchVar is described in the comment for CheckSignatures.
type MatchVar string

func (v MatchVar) Elem() MatchVar {
	return v
}
        
func (_ CheckSignaturesVerbPhraseSurrogate) TypeString(v MatchVar) MatchVar {
	return v
}

